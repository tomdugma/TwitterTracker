# -*- coding: utf-8 -*-
"""Donald Trump Tweets Collector.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1N5Yd1osjqQB6GNFYcgi9j7PdTMwJ3s4f

# *Users Twitter Collector - By Tom Dugma*

## Program purpose:
## 1. Given a username, start date and end date, it retrieves the user`s tweets from twitter between those dates.  you can also store his tweets in a database.
## 2. Given a username it retrieves information about him (current followers count, where he lives, etc..), store it in the database and visualize importent info about him.

### assumptions I made:
### 1. From pdf: "That will have this public methods", I assumed that I can use  more than two public methods.
### 2. I notice that Donald Trump account has been blocked, so i`ve created a generic collector.
### 3. I gather more data from what i`ve been asked, for future possible add-ons.
"""

!pip install tweepy
!pip3 install snscrape

import tweepy
import csv
import pandas as pd
import numpy as np
import os

tweets_columns = ['user', 'timestamp', 'date_integer', 'id_str', 'text', 'hashtags', 'link',
                  'is_replay', 'in_replay_text',
                  'is_quote_status', 'retweet_count', 'post_source',
                  'favorite_count', 'possibly_sensitive'
                  ]

user_info = ['user','date_integer', 'user_url', 'user_location', 'user_description',
             'user_verified', 'user_followers_count', 'user_friends_count',
             'user_listed_count', 'user_favourites_count', 'user_statuses_count']

def to_integer(dt_time):
    return 10000*dt_time.year + 100*dt_time.month + dt_time.day

"""# TwitterTracker class

## given an api key, you can create your own instance of twitter tracker, and collect data about users in Twitter.
"""

# Commented out IPython magic to ensure Python compatibility.
import sqlite3
from datetime import datetime, timedelta
import time
import seaborn as sns
import matplotlib.pyplot as plt
from threading import Thread
import time
from wordcloud import WordCloud, STOPWORDS
import matplotlib.pyplot as plt
from collections import Counter
# %matplotlib inline

class TwitterTracker(object):

  def __init__(self, api_key):
    """
    The constructor creates an object instance that creates a twitter database
    which has 2 tables:
    Table 1: tweets that hold all the tweets retrieve for a given username
    Table 2: users information
    """
    self.max_tweets = 10
    self.api_key = api_key

    self.db_path = '/content/drive/MyDrive/TwitterCollector/twitter.db'
    # if os.path.exists(self.db_path):
    #   os.remove(self.db_path)

    self.conn = sqlite3.connect(self.db_path, timeout=10)
    # connection = sqlite.connect('cache.db', timeout=10)

    print("Opened database successfully");
    columns_str = ''
    columns_str_user = ''
    for col in tweets_columns:
      columns_str =  columns_str + col + ','
    for col in user_info:
      columns_str_user =  columns_str_user + col + ','
    columns_str = columns_str[:-1]
    columns_str_user = columns_str_user[:-1]
    self.conn.execute(f'''CREATE TABLE IF NOT EXISTS tweets({columns_str});''')
    self.conn.execute(f'''CREATE TABLE IF NOT EXISTS users({columns_str_user});''')
    self.conn.commit()
    self.conn.close()

  def _scraper(self, max_tweets, user, from_date, to_date):
    """
    returns: list of tweets ids of a given user between from_date and to_date,
    limied by the max_tweets parameter
    """
    txt_to_use = f'from:{user} since:{from_date} until:{to_date}'
    print(txt_to_use)
    output_path = f'{user}.txt'
    !snscrape --max-results {max_tweets} twitter-search '${txt_to_use}' > {output_path}

    id_links_list = open(output_path, "r").readlines()
    if len(id_links_list) == 0:
      print('WRONG INPUT')
    id_list = [x.split('/')[-1].replace('\n','') for x in id_links_list]
    return id_list

  def _retrieve_user_information(self, user_screen_name):
    """
    This function gets all the importent information about a given user.
    returns: the data in a list.
    """
    user = self.api_key.get_user(user_screen_name)
    data = [user_screen_name, to_integer(datetime.now()),user.url,user.location,user.description,user.verified
            ,user.followers_count,user.friends_count,user.listed_count,user.favourites_count,user.statuses_count]
    return data
    
  def _retrieve_tweets(self, id_list):
    """
    This function gets list of tweets ids, parsing it and clearing garbage text.
    returns: all the data in a list.
    """
    data = []
    batch_size = max(int(len(id_list)/100),1)
    for i in range(0, len(id_list), batch_size):
      for tweet in self.api_key.statuses_lookup(id_list[i:i+batch_size], tweet_mode='extended'):
        if tweet.lang == 'en':
          hashtags_set = {x['text'].lower() for x in tweet.entities['hashtags']}
          in_reply_to_status_id = True if tweet.in_reply_to_status_id != None else False
          replay_tweet = None
          if in_reply_to_status_id == True:
            for x in self.api_key.statuses_lookup([tweet.in_reply_to_status_id_str], tweet_mode='extended'):
              replay_tweet = x.full_text
          data.append([tweet.user.screen_name, tweet.created_at, to_integer(tweet.created_at), tweet.id_str, tweet.full_text,
                      str(hashtags_set) if len(hashtags_set)>0 else '',
                      f'https://twitter.com/{tweet.user.screen_name}/status/{tweet.id}',
                      in_reply_to_status_id,
                      replay_tweet if replay_tweet != None else '',
          tweet.is_quote_status,
          tweet.retweet_count if tweet.retweet_count != None else '',
          tweet.source,
          tweet.favorite_count if tweet.favorite_count != None else '',
          tweet.possibly_sensitive if hasattr(tweet, 'possibly_sensitive') else ''])
    return data

  def _insert_to_db(self, tweet_list):
    """
    This function gets list of tweets that we retrieve for a given user and store it in tweets Table
    returns: void
    """
    self.conn = sqlite3.connect(self.db_path)
    for tweet_element in tweet_list:
      tweet_element[0] = tweet_element[0].lower() 
      self.conn.execute("INSERT INTO tweets VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)", tweet_element)
    self.conn.commit()
    self.conn.close()

  def _insert_to_user_db(self, info_list):
    """
    This function gets list of information that we retrieve for a given user and store it in users Table
    returns: void
    """
    self.conn = sqlite3.connect(self.db_path)
    print(info_list)
    self.conn.execute("INSERT INTO users VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)", info_list)
    self.conn.commit()
    self.conn.close()

  def collect_daily_info(self, user):
    """
    This function Runs every 24 hours, and retrieve current information about a given user and store it in the database.
    returns: void
    """
    info_list = self._retrieve_user_information(user)
    self._insert_to_user_db(info_list)
    print(f'collected daily info on user: {user}')

  def Collect(self, from_date, to_date, user):              # Tech 1
    """
    This function gets a username, start date and end date.
    The function will retrieve all the tweets between the dates given of the user and store it in the database.
    returns: void
    """
    id_list = self._scraper(self.max_tweets, user, from_date, to_date)
    tweet_list = self._retrieve_tweets(id_list)
    self._insert_to_db(tweet_list)
    
  def View(self, from_date, to_date, user='all'):           # Tech 2
    """
    This function gets a all as default, but specific username is possible also, start date and end date.
    The function will retrieve statistical information between the dates given of the user/all and will present.
    returns: void
    """
    self.conn = sqlite3.connect(self.db_path)
    new_from_date = to_integer(datetime.fromisoformat(from_date))
    new_to_date = to_integer(datetime.fromisoformat(to_date))

    # Favorite Count
    if user == 'all':
      query = f'''SELECT * FROM tweets 
      WHERE date_integer BETWEEN {new_from_date} AND {new_to_date};'''
    else:
      query =  f"SELECT * FROM tweets WHERE  user LIKE '{user}' AND date_integer BETWEEN {new_from_date} AND {new_to_date};"     
    df = pd.read_sql_query(query, self.conn)
    # print(df)
    df = df.sort_values(by=['timestamp'], ascending=True)
    plt.xticks(rotation=90)
    plt.rcParams["figure.figsize"] = (15,10)
    sns.lineplot(x="timestamp", y="favorite_count",
             hue="user", style="user",
             data=df)
    plt.title('favorite counts between given dates')
    plt.show()
    self.conn.close()

  def showTwittsCountInDB(self):
    """
    This function gets a all as default, but specific username is possible also, start date and end date.
    The function will retrieve statistical information between the dates given of the user/all and will present.
    returns: void
    """
      self.conn = sqlite3.connect(self.db_path)
      New_Colors = ['green','blue','purple','brown','teal']
      query =  f"SELECT user, COUNT(user) as tweetsCount FROM tweets GROUP BY user;"
      df = pd.read_sql_query(query, self.conn)
      plt.bar(df['user'], df['tweetsCount'],color=New_Colors)
      plt.title('Amount of tweets gather in the database so far')
      plt.xlabel('User',fontsize=14)
      plt.ylabel('Tweets Count',fontsize=14)
      plt.grid(True)
      plt.show()
      self.conn.close()

  def getRetweetsAmountSinceBeggingingOfTheMonth(self, user): # 2.a
    """
    This function gets a username and prints the amount of retweets since the beggining of the month
    returns: void
    """
    self.conn = sqlite3.connect(self.db_path)
    cursor = self.conn.cursor()
    today = datetime.today()
    firstOfMonth = today - timedelta(today.day - 1)
    today2 = to_integer(today)
    firstOfMonth2 = to_integer(firstOfMonth)
    query = f"SELECT SUM(retweet_count) FROM tweets WHERE  user LIKE '{user}' AND date_integer BETWEEN {firstOfMonth2} AND {today2};"
    retweetCount = cursor.execute(query).fetchall()[0][0]
    print(f'the user {user} retweet count from {firstOfMonth} to {today} is: {retweetCount}')
    cursor.close()
    self.conn.commit()

  def getUserFollowersCount(self, user): # 2.b
    """
    This function gets a username and prints the amount of followers he has.
    returns: void
    """
    self.conn = sqlite3.connect(self.db_path)
    cursor = self.conn.cursor()
    query = f"SELECT * FROM users WHERE  user LIKE '{user}';"
    followersCount = cursor.execute(query).fetchall()[0][0]
    print(f'the user {user} followers count is: {followersCount}')
    cursor.close()
    self.conn.commit()

  def getUserFollowersGrowth(self, user): # 2.cq
    """
    This function gets a username and prints the growth in followers he has today, compare to yesterday.
    returns: void
    """
    self.conn = sqlite3.connect(self.db_path)
    cursor = self.conn.cursor()
    today = datetime.today()
    yesterday = today - timedelta(1)
    today = to_integer(today)
    yesterday = to_integer(yesterday)
    queryToday = f"SELECT user_followers_count FROM users WHERE  user LIKE '{user}' AND date_integer LIKE '{today}';"
    queryYesterday = f"SELECT user_followers_count FROM users WHERE  user LIKE '{user}' AND date_integer LIKE '{yesterday}';"
    followersCountToday = cursor.execute(queryToday).fetchall()[0][0]
    followersCountYesterday = cursor.execute(queryYesterday).fetchall()[0][0]
    print(f'the ratio between num of followers today and yesterday is: {followersCountToday / followersCountYesterday} ')

  def gatherWords(self, MAX_TWEETS=15):
    """
    This function gets MAX_TWEETS as integer.
    returns: list contain all the words from the MAX_TWEETS tweets
    """
    self.conn = sqlite3.connect(self.db_path)
    cursor = self.conn.cursor()
    data = cursor.execute(f"SELECT text FROM tweets")
    words_list = []
    for i,tweet in enumerate(data):
      curr_words = tweet[0].split()
      for w in curr_words:
        words_list.append(w)
      if i > MAX_TWEETS:
        break
    return words_list

  def drawWordCloud(self, words_list, min_times=1):
    """
    This function gets a words_list and a min_times as params.
    returns: return a word cloud, presenting the most common words in the words_list, that above min_times argument.
    """
    stopwords = set(STOPWORDS)
    stopwords.append('The') 
    stopwords_parts = {"'s", " ' s'", " `s" }
    wordcloud = WordCloud(width = 800, height = 800, 
                    background_color ='white', 
                    stopwords = stopwords, 
                    min_font_size = 10)
    def skip_entity(e):
        if e in stopwords:
            return True
        for p in stopwords_parts:
            if p in e:
                return True
        return False
    c = Counter(words_list)
    # using the subject frquencies
    d = {k:v for k,v in dict(c).items() if v > min_times and not skip_entity(k)}
    wordcloud.generate_from_frequencies(d)
    plt.figure(figsize = (10, 10), facecolor = None) 
    plt.title('Most common words in the tweets database')
    plt.imshow(wordcloud)

"""# MAIN

## from here you can run your twitter tracker, and visualize information about users.
"""

# Please, put your personal key, secret and token that belongs to you.
consumer_key = 'YOUR CODE HERE'
consumer_secret = 'YOUR CODE HERE'
access_token = 'YOUR CODE HERE'
access_token_secret = 'YOUR CODE HERE'
# Please, put your personal key, secret and token that belongs to you.


#--------------------------------------------------------------#

# Initiliaze the Twitter collector
auth = tweepy.OAuthHandler(consumer_key, consumer_secret)
auth.set_access_token(access_token, access_token_secret)
api_key = tweepy.API(auth,wait_on_rate_limit=True,wait_on_rate_limit_notify=True)
t = TwitterTracker(api_key)

# Collect twitts of specific user, for example: 'potus' A.K.A Joe Biden between specific dates.
# t.Collect('2020-01-01', '2021-08-10', 'potus')
# t.Collect('2021-01-01', '2021-08-10', 'justinbieber')
# t.Collect('2021-01-01', '2021-08-10', 'barackobama')
#
# t.getRetweetsAmountSinceBeggingingOfTheMonth('barackobama')
# t.collect_daily_info('barackobama')
# t.getUserFollowersCount('barackobama')
# t.getUserFollowersGrowth('barackobama')

# Keep tracking daily on Joe Biden
while True:
  t.collect_daily_info('potus')
  print('Sleep for 24 hours')
  time.sleep(24 * 60 * 60)

"""# Let show the amount of favorite people between given dates for each user """

t.View('2021-01-01', '2021-08-01', 'all')

"""# Let show the amount of tweets we have in the database per user:"""

t.showTwittsCountInDB()

"""#Let's find the most common words in the twitts database:



"""

a = t.gatherWords(20)
t.drawWordCloud(a)